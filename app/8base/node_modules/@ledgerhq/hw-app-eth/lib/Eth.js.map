{"version":3,"sources":["../src/Eth.js"],"names":["Eth","transport","scrambleKey","decorateAppAPIMethods","path","boolDisplay","boolChaincode","paths","buffer","Buffer","length","forEach","element","index","writeUInt32BE","send","then","result","publicKeyLength","response","addressLength","publicKey","slice","toString","address","chainCode","rawTxHex","offset","rawTx","toSend","maxChunkSize","chunkSize","copy","push","data","i","apduResponse","v","r","s","arbitraryDataEnabled","version","messageHex","message"],"mappings":"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","file":"Eth.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\"\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string\n  }> {\n    let paths = splitPath(path);\n    let buffer = new Buffer(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = new Buffer(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response.slice(0, 1).toString(\"hex\");\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    version: string\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = new Buffer(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n}\n"]}