import { ECSignature, SignatureType, SignerType } from '@0xproject/types';
import { Provider } from 'ethereum-types';
export declare const signatureUtils: {
    /**
     * Verifies that the provided signature is valid according to the 0x Protocol smart contracts
     * @param   data          The hex encoded data signed by the supplied signature.
     * @param   signature     A hex encoded 0x Protocol signature made up of: [TypeSpecificData][SignatureType].
     *          E.g [vrs][SignatureType.EIP712]
     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.
     * @return  Whether the signature is valid for the supplied signerAddress and data.
     */
    isValidSignatureAsync(provider: Provider, data: string, signature: string, signerAddress: string): Promise<boolean>;
    /**
     * Verifies that the provided presigned signature is valid according to the 0x Protocol smart contracts
     * @param   provider      Web3 provider to use for all JSON RPC requests
     * @param   data          The hex encoded data signed by the supplied signature
     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.
     * @return  Whether the data was preSigned by the supplied signerAddress
     */
    isValidPresignedSignatureAsync(provider: Provider, data: string, signerAddress: string): Promise<boolean>;
    /**
     * Verifies that the provided wallet signature is valid according to the 0x Protocol smart contracts
     * @param   provider      Web3 provider to use for all JSON RPC requests
     * @param   data          The hex encoded data signed by the supplied signature.
     * @param   signature     A hex encoded presigned 0x Protocol signature made up of: [SignatureType.Presigned]
     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.
     * @return  Whether the data was preSigned by the supplied signerAddress.
     */
    isValidWalletSignatureAsync(provider: Provider, data: string, signature: string, signerAddress: string): Promise<boolean>;
    /**
     * Verifies that the provided validator signature is valid according to the 0x Protocol smart contracts
     * @param   provider      Web3 provider to use for all JSON RPC requests
     * @param   data          The hex encoded data signed by the supplied signature.
     * @param   signature     A hex encoded presigned 0x Protocol signature made up of: [SignatureType.Presigned]
     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.
     * @return  Whether the data was preSigned by the supplied signerAddress.
     */
    isValidValidatorSignatureAsync(provider: Provider, data: string, signature: string, signerAddress: string): Promise<boolean>;
    /**
     * Checks if the supplied elliptic curve signature corresponds to signing `data` with
     * the private key corresponding to `signerAddress`
     * @param   data          The hex encoded data signed by the supplied signature.
     * @param   signature     An object containing the elliptic curve signature parameters.
     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.
     * @return Whether the ECSignature is valid.
     */
    isValidECSignature(data: string, signature: ECSignature, signerAddress: string): boolean;
    /**
     * Signs an orderHash and returns it's elliptic curve signature and signature type.
     * This method currently supports TestRPC, Geth and Parity above and below V1.6.6
     * @param   orderHash       Hex encoded orderHash to sign.
     * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address
     *          must be available via the Provider supplied to 0x.js.
     * @param   signerType Different signers add/require different prefixes to be prepended to the message being signed.
     *          Since we cannot know ahead of time which signer you are using, you must supply a SignerType.
     * @return  A hex encoded string containing the Elliptic curve signature generated by signing the orderHash and the Signature Type.
     */
    ecSignOrderHashAsync(provider: Provider, orderHash: string, signerAddress: string, signerType: SignerType): Promise<string>;
    /**
     * Combines ECSignature with V,R,S and the relevant signature type for use in 0x protocol
     * @param ecSignature The ECSignature of the signed data
     * @param signerType The SignerType of the signed data
     * @return Hex encoded string of signature (v,r,s) with Signature Type
     */
    convertECSignatureToSignatureHex(ecSignature: ECSignature, signerType: SignerType): string;
    /**
     * Combines the signature proof and the Signature Type.
     * @param signature The hex encoded signature proof
     * @param signatureType The signature type, i.e EthSign, Wallet etc.
     * @return Hex encoded string of signature proof with Signature Type
     */
    convertToSignatureWithType(signature: string, signatureType: SignatureType): string;
    /**
     * Adds the relevant prefix to the message being signed.
     * @param message Message to sign
     * @param signerType The type of message prefix to add for a given SignerType. Different signers expect
     *                          specific message prefixes.
     * @return Prefixed message
     */
    addSignedMessagePrefix(message: string, signerType?: SignerType): string;
    /**
     * Parse a 0x protocol hex-encoded signature string into it's ECSignature components
     * @param signature A hex encoded ecSignature 0x Protocol signature
     * @return An ECSignature object with r,s,v parameters
     */
    parseECSignature(signature: string): ECSignature;
};
//# sourceMappingURL=signature_utils.d.ts.map