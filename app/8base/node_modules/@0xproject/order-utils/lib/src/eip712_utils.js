"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ethUtil = require("ethereumjs-util");
var _ = require("lodash");
var crypto_1 = require("./crypto");
var types_1 = require("./types");
var EIP191_PREFIX = '\x19\x01';
var EIP712_DOMAIN_NAME = '0x Protocol';
var EIP712_DOMAIN_VERSION = '2';
var EIP712_VALUE_LENGTH = 32;
var EIP712_DOMAIN_SCHEMA = {
    name: 'EIP712Domain',
    parameters: [
        { name: 'name', type: types_1.EIP712Types.String },
        { name: 'version', type: types_1.EIP712Types.String },
        { name: 'verifyingContract', type: types_1.EIP712Types.Address },
    ],
};
exports.eip712Utils = {
    /**
     * Compiles the EIP712Schema and returns the hash of the schema.
     * @param   schema The EIP712 schema.
     * @return  The hash of the compiled schema
     */
    compileSchema: function (schema) {
        var eip712Schema = exports.eip712Utils._encodeType(schema);
        var eip712SchemaHashBuffer = crypto_1.crypto.solSHA3([eip712Schema]);
        return eip712SchemaHashBuffer;
    },
    /**
     * Merges the EIP712 hash of a struct with the DomainSeparator for 0x v2.
     * @param   hashStruct the EIP712 hash of a struct
     * @param   contractAddress the exchange contract address
     * @return  The hash of an EIP712 message with domain separator prefixed
     */
    createEIP712Message: function (hashStruct, contractAddress) {
        var domainSeparatorHashBuffer = exports.eip712Utils._getDomainSeparatorHashBuffer(contractAddress);
        var messageBuff = crypto_1.crypto.solSHA3([EIP191_PREFIX, domainSeparatorHashBuffer, hashStruct]);
        return messageBuff;
    },
    /**
     * Pad an address to 32 bytes
     * @param address Address to pad
     * @return padded address
     */
    pad32Address: function (address) {
        var addressBuffer = ethUtil.toBuffer(address);
        var addressPadded = exports.eip712Utils.pad32Buffer(addressBuffer);
        return addressPadded;
    },
    /**
     * Pad an buffer to 32 bytes
     * @param buffer Address to pad
     * @return padded buffer
     */
    pad32Buffer: function (buffer) {
        var bufferPadded = ethUtil.setLengthLeft(buffer, EIP712_VALUE_LENGTH);
        return bufferPadded;
    },
    /**
     * Hash together a EIP712 schema with the corresponding data
     * @param schema EIP712-compliant schema
     * @param data Data the complies to the schema
     * @return A buffer containing the SHA256 hash of the schema and encoded data
     */
    structHash: function (schema, data) {
        var encodedData = exports.eip712Utils._encodeData(schema, data);
        var schemaHash = exports.eip712Utils.compileSchema(schema);
        var hashBuffer = crypto_1.crypto.solSHA3(__spread([schemaHash], encodedData));
        return hashBuffer;
    },
    _getDomainSeparatorSchemaBuffer: function () {
        return exports.eip712Utils.compileSchema(EIP712_DOMAIN_SCHEMA);
    },
    _getDomainSeparatorHashBuffer: function (exchangeAddress) {
        var domainSeparatorSchemaBuffer = exports.eip712Utils._getDomainSeparatorSchemaBuffer();
        var encodedData = exports.eip712Utils._encodeData(EIP712_DOMAIN_SCHEMA, {
            name: EIP712_DOMAIN_NAME,
            version: EIP712_DOMAIN_VERSION,
            verifyingContract: exchangeAddress,
        });
        var domainSeparatorHashBuff2 = crypto_1.crypto.solSHA3(__spread([domainSeparatorSchemaBuffer], encodedData));
        return domainSeparatorHashBuff2;
    },
    _encodeType: function (schema) {
        var namedTypes = _.map(schema.parameters, function (_a) {
            var name = _a.name, type = _a.type;
            return type + " " + name;
        });
        var namedTypesJoined = namedTypes.join(',');
        var encodedType = schema.name + "(" + namedTypesJoined + ")";
        return encodedType;
    },
    _encodeData: function (schema, data) {
        var e_1, _a;
        var encodedValues = [];
        try {
            for (var _b = __values(schema.parameters), _c = _b.next(); !_c.done; _c = _b.next()) {
                var parameter = _c.value;
                var value = data[parameter.name];
                if (parameter.type === types_1.EIP712Types.String || parameter.type === types_1.EIP712Types.Bytes) {
                    encodedValues.push(crypto_1.crypto.solSHA3([ethUtil.toBuffer(value)]));
                }
                else if (parameter.type === types_1.EIP712Types.Uint256) {
                    encodedValues.push(value);
                }
                else if (parameter.type === types_1.EIP712Types.Address) {
                    encodedValues.push(exports.eip712Utils.pad32Address(value));
                }
                else {
                    throw new Error("Unable to encode " + parameter.type);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return encodedValues;
    },
};
//# sourceMappingURL=eip712_utils.js.map